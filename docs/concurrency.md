# 동시성 이슈 해결 문서

## 개요

e-커머스 상품 주문 서비스에서 발생할 수 있는 동시성 이슈를 식별하고 해결한 내용을 정리합니다.

## 식별된 동시성 이슈

### 1. 재고 Oversell 문제
**문제 상황:**
- 다수 사용자가 동시에 같은 상품을 주문할 때, 재고 확인과 차감 사이의 시간 차이로 인해 재고가 음수가 되거나 초과 판매되는 문제가 발생할 수 있습니다.

**예시 시나리오:**
```
상품 재고: 10개
사용자 A: 재고 확인 (10개) → 주문 처리 → 재고 차감 (9개)
사용자 B: 재고 확인 (10개) → 주문 처리 → 재고 차감 (9개) ← 동시에 실행되면 문제 발생
```

### 2. 잔액 음수 오류
**문제 상황:**
- 동일 유저가 두 번의 결제 요청을 동시에 보낼 때, 잔액 확인과 차감 사이의 시간 차이로 인해 잔액이 음수가 되는 문제가 발생할 수 있습니다.

**예시 시나리오:**
```
사용자 잔액: 10,000원
결제 요청 A: 잔액 확인 (10,000원) → 결제 처리 → 잔액 차감 (4,000원)
결제 요청 B: 잔액 확인 (10,000원) → 결제 처리 → 잔액 차감 (4,000원) ← 동시에 실행되면 문제 발생
```

### 3. 쿠폰 초과 발급 / 중복 발급
**문제 상황:**
- 선착순 쿠폰 발급 요청이 몰릴 때, 쿠폰 개수 확인과 발급 사이의 시간 차이로 인해 제한 개수를 초과하여 발급되거나 중복 발급되는 문제가 발생할 수 있습니다.

**예시 시나리오:**
```
쿠폰 발급 제한: 100개
요청 A: 쿠폰 개수 확인 (99개) → 쿠폰 발급 → 총 100개
요청 B: 쿠폰 개수 확인 (99개) → 쿠폰 발급 → 총 101개 ← 동시에 실행되면 문제 발생
```

## 해결 전략

### 1. 재고 감소 동시성 제어

**해결 방법: 조건부 UPDATE**

```java
@Modifying
@Query("UPDATE Product p SET p.stock = p.stock - :quantity WHERE p.id = :productId AND p.stock >= :quantity")
int decreaseStockIfAvailable(@Param("productId") Long productId, @Param("quantity") Integer quantity);
```

**동작 원리:**
- WHERE 절에 재고 조건을 포함하여, 재고가 충분한 경우에만 UPDATE가 실행됩니다.
- UPDATE 문은 원자적으로 실행되므로, 동시 요청이 있어도 재고가 음수가 되지 않습니다.
- 영향받은 행 수를 반환하여, 0이면 재고 부족, 1이면 성공을 판단할 수 있습니다.

**장점:**
- 데이터베이스 레벨에서 원자적으로 처리되어 안전합니다.
- 비관적 락보다 성능이 좋습니다 (락 대기 시간 없음).
- 재고 부족 시 즉시 실패 처리 가능합니다.

### 2. 잔액 차감 동시성 제어

**해결 방법: 조건부 UPDATE**

```java
@Modifying
@Query("UPDATE User u SET u.balance = u.balance - :amount WHERE u.id = :userId AND u.balance >= :amount")
int deductBalanceIfAvailable(@Param("userId") Long userId, @Param("amount") Long amount);
```

**동작 원리:**
- WHERE 절에 잔액 조건을 포함하여, 잔액이 충분한 경우에만 UPDATE가 실행됩니다.
- UPDATE 문은 원자적으로 실행되므로, 동시 요청이 있어도 잔액이 음수가 되지 않습니다.
- 영향받은 행 수를 반환하여, 0이면 잔액 부족, 1이면 성공을 판단할 수 있습니다.

**장점:**
- 데이터베이스 레벨에서 원자적으로 처리되어 안전합니다.
- 비관적 락보다 성능이 좋습니다.
- 잔액 부족 시 즉시 실패 처리 가능합니다.

### 3. 쿠폰 발급 동시성 제어

**해결 방법: SELECT FOR UPDATE (비관적 락)**

```java
@Lock(LockModeType.PESSIMISTIC_WRITE)
@Query("SELECT COUNT(c) FROM Coupon c WHERE c.status = 'ACTIVE'")
Long countActiveCouponsWithLock();
```

**동작 원리:**
- SELECT FOR UPDATE를 사용하여 쿠폰 개수를 조회할 때 락을 걸어 다른 트랜잭션이 동시에 접근하지 못하도록 합니다.
- 락이 걸린 상태에서 쿠폰 개수를 확인하고, 제한 이하인 경우에만 쿠폰을 발급합니다.
- 다른 트랜잭션은 락이 해제될 때까지 대기합니다.

**장점:**
- 쿠폰 개수 확인과 발급 사이에 다른 트랜잭션이 개입하지 못합니다.
- 제한 개수를 정확하게 지킬 수 있습니다.

**선택 이유:**
- 쿠폰 발급은 COUNT 쿼리와 INSERT가 분리되어 있어, 조건부 UPDATE만으로는 해결하기 어렵습니다.
- SELECT FOR UPDATE를 사용하여 쿠폰 개수 확인 시점에 락을 걸어 동시성 문제를 해결합니다.

## 테스트 결과

### 1. 재고 감소 동시성 테스트

**테스트 시나리오:**
- 재고 100개, 150명이 동시에 1개씩 주문

**결과:**
- 성공한 주문 수: 100개
- 실패한 주문 수: 50개
- 최종 재고: 0개
- ✅ 재고가 음수가 되지 않음
- ✅ 성공한 주문 수 + 남은 재고 = 초기 재고

### 2. 잔액 차감 동시성 테스트

**테스트 시나리오:**
- 잔액 10,000원, 동일 유저가 동시에 6,000원씩 2번 결제 시도

**결과:**
- 성공한 주문 수: 1개
- 실패한 주문 수: 1개
- 최종 잔액: 4,000원
- ✅ 잔액이 음수가 되지 않음
- ✅ 성공한 주문은 최대 1개 (잔액이 6,000원이므로 1개만 가능)

### 3. 쿠폰 발급 동시성 테스트

**테스트 시나리오:**
- 쿠폰 발급 제한 100개, 150명이 동시에 쿠폰 발급 요청

**결과:**
- 성공한 쿠폰 발급 수: 100개
- 실패한 쿠폰 발급 수: 50개
- 실제 발급된 쿠폰 수: 100개
- ✅ 쿠폰 발급 개수가 100개를 초과하지 않음

### 4. 복합 동시성 테스트

**테스트 시나리오:**
- 재고 50개, 잔액 50,000원, 쿠폰 발급 제한 100개
- 100명이 동시에 주문 및 쿠폰 발급 요청

**결과:**
- 성공한 주문 수: 50개 이하
- 성공한 쿠폰 발급 수: 100개 이하
- 최종 재고: 0개 이상
- 최종 잔액: 0원 이상
- 발급된 쿠폰 수: 100개 이하
- ✅ 모든 제약 조건이 지켜짐

## 구현된 동시성 제어 기법

1. **조건부 UPDATE** (재고 감소, 잔액 차감)
   - WHERE 절에 조건을 포함하여 원자적으로 처리
   - 영향받은 행 수를 반환하여 성공/실패 판단

2. **SELECT FOR UPDATE** (쿠폰 발급)
   - 비관적 락을 사용하여 동시 접근 제어
   - 쿠폰 개수 확인과 발급 사이에 다른 트랜잭션 개입 방지

## 성능 고려사항

- **조건부 UPDATE**: 비관적 락보다 성능이 좋습니다. 락 대기 시간이 없고, 실패 시 즉시 반환됩니다.
- **SELECT FOR UPDATE**: 락 대기 시간이 발생할 수 있지만, 쿠폰 발급과 같은 제한적인 상황에서는 적절한 선택입니다.

## 결론

조건부 UPDATE와 SELECT FOR UPDATE를 적절히 사용하여 동시성 이슈를 해결했습니다. 모든 테스트에서 재고 oversell, 잔액 음수, 쿠폰 초과 발급 문제가 발생하지 않음을 확인했습니다.
